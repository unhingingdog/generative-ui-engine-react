# Shadowboxin: Generative UI Engine for React

A lightweight, streaming-first library for building dynamic React user interfaces generated by Large Language Models.

This is beta. It's a work in active progress, and completely unreliable.

This package provides the core engine and utilities to render a (streamed) UI from a stream of JSON data, allowing you to create conversational, AI-driven applications with ease.

## Installation

```bash
npm install shadowboxin
```

## Core Packages

This library is split into subpackages, allowing you to import only the parts you need.

- **`shadowboxin/engine`**: The heart of the library. Contains the `createEngine` function that takes a stream of partial JSON, validates it, and renders the corresponding React components.
- **`shadowboxin/template-utils`**: Utilities for connecting your React components to the engine. The main export is `createTemplateRegistry`, which you use to define the components the AI can use.
- **`shadowboxin/template-models`**: Zod schemas and TypeScript types for validating the data structures sent from the AI.
- **`shadowboxin/agent`**: A high-level client for managing the connection to your AI backend. The `createClient` function connects the engine to a streaming data source and manages the conversation.

## Quick Start

Hereâ€™s the simplest way to get the engine running.

### 1. Define your Components & Registry

Create your React components and a `registry` that maps them to a string ID and a Zod validation schema.

```typescript
// src/my-registry.ts
import { createTemplateRegistry, type TemplatePair } from 'shadowboxin/template-utils';
import { z } from 'zod';

const MyHeading = ({ content }: { content: string }) => <h1>{content}</h1>;
const MyParagraph = ({ content }: { content: string }) => <p>{content}</p>;

const HeadingPair: TemplatePair<any, any, any> = {
  type: "heading",
  instructions: { generalUsage: "A title or heading." },
  templateValidator: z.object({ id: z.literal("heading"), content: z.string() }),
  component: MyHeading,
};

const ParagraphPair: TemplatePair<any, any, any> = {
  type: "paragraph",
  instructions: { generalUsage: "A block of text." },
  templateValidator: z.object({ id: z.literal("paragraph"), content: z.string() }),
  component: MyParagraph,
};

export const registry = createTemplateRegistry(HeadingPair, ParagraphPair);
```

### 2. Connect the Engine and Client

Now, initialize the engine and use the `createClient` utility to connect it to a data stream.

```typescript
// src/setup-generative-ui.ts
import { createEngine } from "shadowboxin/engine";
import { createClient, generateSystemPrompt } from "shadowboxin/agent";
import { registry } from "./my-registry";

// A mock AI stream for this example
async function* mockStreamFactory() {
  const response = `{"id":"heading","content":"Hello, World!"}`;
  for (const char of response) {
    yield char;
    await new Promise((res) => setTimeout(res, 50));
  }
}

// This function sets everything up
export async function setupGenerativeUI(rootElement: HTMLElement) {
  let client;

  const engine = await createEngine({
    registry,
    rootNode: rootElement,
    onSubmit: (payloads) => client?.submit(payloads),
  });

  const enginePort = {
    next: (delta: string) => engine.push(delta),
    reset: () => engine.reset(),
  };

  client = createClient({
    engine: enginePort,
    systemPrompt: generateSystemPrompt(
      "You are a helpful assistant.",
      registry.instructions,
    ),
    provider: {
      type: "client",
      streamFactory: mockStreamFactory,
    },
  });

  await client.run();
}
```

You would then call `setupGenerativeUI(document.getElementById('root'))` from your main application file.
